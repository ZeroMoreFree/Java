## 文章是我从另外一个网站翻译的，翻译水平有限，共勉。原文链接：[Non-blocking Server](http://tutorials.jenkov.com/java-nio/non-blocking-server.html)

![design](http://tutorials.jenkov.com/images/java-nio/non-blocking-server-4.png)
1. 组件通过询问Selector，查看是否有可以阅读的Channel，有的话就返回那个channel实例。一个被选出来的Channel，我们可以把它视为一个data block，我们并不知道这个block里面有多少完整的消息，也许是一条，也是大于或者小于一条，总之，极有可能是不完整的、部分的消息。

2. 我们在处理这些不完整的信息的时候，需要做两件事，这两件事都充满了挑战：
  * 我们想要更少的信息拷贝，拷贝的次数越少，则性能越高。
  * 为了使得消息解析的时候更加方便，我们需要把完整的信息存储在连续的字节数组中。

3. 检测信息
   * 检测信息需要MessageReader从block中查看是否有至少一条完整的信息，如果有的话，则该完整信息可以拿出来进行处理。以上的步骤，需要重复多次，所以最好能提高处理的效率。
   * 当block中有不完整的信息，我们则需要把不完整的信息存储起来，直到它的另一部分从channel里面到达使其成为完整的信息。
   * 检查完整信息和存储不完整信息，都是MessageReader的责任，为了不使不同的channel的消息混淆，我们需要让每个channel拥有一个属于自己的MessageReader。
   * 当我们从selector取出一个可以被read的channel的时候，其对应的MessageReader就会从channel中读取消息并且进行消息的分解，如果发现有完整的信息，则把该信息交给处理该信息的组件。
   * 每一个MessageReader都是为指定的协议工作的，它需要知道它所读的信息的的格式。

4. 存储信息
   * 做设计存储信息的时候，需要考虑两点:A.我们想要更少的信息拷贝，拷贝的次数越少，则性能越高。B.为了使得消息解析的时候更加方便，我们需要把完整的信息存储在连续的字节数组中。
   * 给每个MessageReader持有一个Buffer
     * 那么这个buffer需要的大小是多少呢？它需要大到至少能存储我们能接受得到的最大的消息的大小。如果我们能接收的最大消息体是10M，则改buffer的体积就需要是10M。
     * 但是我们不可能真的给每个buffer都这么大到体积，因为如果我们拥有1000000这样的示例的话，则我们需要相当大的内存，况且并不是每个消息体都这么大，给每个buffer10M的体积，无疑是非常浪费且不实际的做法。
   * 设计可伸缩的buffer:给每个MessageReader持有一个可伸缩的buffer，这个buffer一开始的体积会很小，如果消息体的体积大于buffer的体积的时候，则使buffer扩展。
   * 如何设计可伸缩的buffer---resize by copy
     * 假如一开始我们拥有一个4KB的buffer，如果我们发现我们的消息体放不进去，则我们再分配一个8KB的buffer，然后把4KB的buffer的数据拷贝出来，连同channel余下的信息一起放到8KB的buffer中去。如果数据大于8KB，则分配一个更大的，如此循环。
     * resize-by-copy的做法的优点是：信息将会存在一个单独的、连续性的字节数组中，这会让消息的解析更加方便。
     * resize-by-copy的做法的缺点是：当消息体过大的时候，则需要多次的数组分配和数据拷贝，这将影响性能。
     * 减少数据拷贝和数组分配的次数的关键做法是，需要从你的应用系统中进行分析，看看主要有什么规模的数据，然后制定对应的相关规模的buffer。比如说，你发现你的系统会收到很多低于4KB的信息。则你的第一个buffer的大小可以是4KB。接着，你还发现你有不少数量的大于4KB小于128KB的信息，比如包含了一些小的上传文件，则此时可以设定第二个buffer的大小是128KB。最后，你还发现你有一些大于128KB的信息输入，则第三个buffer按照信息体的最大体积制定。
     * 此时，根据系统分析，你已经制定了三个不同体积大小的buffer，分别是4KB,128KB以及1MB（假设这是消息体的最大体积）。则当消息大于4KB小于128KB的时候，只需要一次数据拷贝和数组分配，如果是大于128KB的时候，则是两次。这样子的次数和数据拷贝量并不算多。最多只需要拷贝4KB+128KB=132KB的数据。
     * 当消息被完全处理好的时候，需要对分配的内存进行释放。然后新的链接还是从4KB的buffer开始走程序。
   * 如何设计可伸缩的buffer---resize by append
     * buffer是由多个数组组成的，当buffer需要扩容的时候，则继续分配数组，并且把数据写进去。
     * 具体实现是，分配一些单独的数组，并且用list保存维护起来。
     * 优点是：扩容的时候，不需要额外的数据拷贝，只需要把数据保存到新分配的数组就行。
     * 缺点是：数据不是保存在一个单独的、连续性的数组中，这使得信息的解析十分困难，所以这种方式其实很难用到实际工作中。
5. TLV格式编码消息
   * 一些协议式的消息使用的是TLV（type,length,value）格式编码。它将消息体的总大小保存在消息体的开始处，当消息到达的时候，我们可以立刻知道消息体的大小并且为其分配一样大小的内存。
   * 缺点：内存在消息完成到达之前就分配好，则如果链接速度很慢而且消息体又非常大的时候，可能会把你可用的内存都占用尽，使得你的服务器无法对请求做出响应。
   * 有两种解决方法：
     * 将消息体分解为不同的字段，每个字段都是TVL格式，服务器收到消息体之后，按照字段分配内存，而不是一开始就为整个消息体分配内存。
     * 设置超时时间，如果消息体在例如10-15秒的时间内没有被接收完毕，则认定为超时，进行特殊处理。
6. 写入不完整的信息
   * 在非阻塞式的IO管道中写入数据也是具有挑战性的。当你调用一个处于非阻塞式的channel的write方法的时候，是无法保证一次可以写入多少字节的。write方法会返回写入的字节的个数，让我们有可能去记录已经写入的字节。而这正是具有挑战性的地方：我们需要追踪记录不完整的信息以便一个消息最后能成功发送它所有的字节。
   * 像之前的MessageReader一样，我们也会为每个channel分配一个MessageWriter用来管理这个channel，在每个MessageWriter里面我们会跟踪记录当前正在写入的信息已经写入了多少字节。
   * MessageWriter一次能写入channel的信息数量有限，所以信息需要在MessageWriter里面排队，然后MessageWriter会尽快地把信息写入channel。
   ![MessageQuenedUp](http://tutorials.jenkov.com/images/java-nio/non-blocking-server-8.png)
   * 当你拥有大量的请求的时候，则你会有大量的MessageWirter实例，去检查这些实例是否能写入信息是很费时的，这需要分开两点来说:
     * 大量MessageWriter里面，也是有大部分是没有信息可以进行写入的
     * 就算MessageWriter可以写入，但是其对应的channel不一定已经准备好可以被写入。
   * 尽管你可以把channel注册到selector里面来检查channel是否已经准备好被写入了，但是你大概还是不想要这样做。想象一下你有1000000channel，而且大部分还是闲置的，然后把这1000000个channel都注册到selector中。然后调用select（）方法，则此时会有大量的channel是准备好被写入的（因为大部分都是闲置的），那么你就需要去检查其对应的writer是否有数据可以写入了。
   * 为了防止进行大量低效率的检测，我们使用以下两个步骤:
     * 当一条消息被写入到MessageWirter之后，我们把这个MessageWriter对应的channel注册到selector之中（假如还未注册的话）
     * 当服务器空闲的时候，就去检查Selector，看看哪个channel应准备好了被写入，准备好的话，则其对应的writer进行写入，当writer把全部信息都写好的时候，则把该channel从selector中注销掉。
7. 结合
   * 如你所见，一个非阻塞式服务器需要时不时地区检查进来的数据看看有没有完整的消息被接收。服务器需要多次检查直到一条或者多条完整的消息被接收，如果只检查一次的话是不够的。
   * 类似地，一个非阻塞式服务器需要时不时地检查有没有数据可以进行写的操作，如果有的话，则服务器需要去检查其对应的链接是否已经准备好被写入，这种检查也是需要多次地执行，检查一次是不够的。
   * 综上所述，一个非阻塞式的服务器最终需要定期地执行三个管道：
     * 一个从开启的链接中检测是否有可以新读入的数据的“读”管道
     * 一个处理完整信息的“处理”管道
     * 一个检测是否有新数据可以往外写出给一个开启的链接的“写”管道
   * 这个三个管道在一个循环中重复地执行，你可以根据自己的需要进行优化。
   
   
   
   
   
   
   
   
   
   
   
