## 文章是我从另外一个网站翻译的，翻译水平有限，共勉。原文链接：[Non-blocking Server](http://tutorials.jenkov.com/java-nio/non-blocking-server.html)

![design](http://tutorials.jenkov.com/images/java-nio/non-blocking-server-4.png)
* 组件通过询问Selector，查看是否有可以阅读的Channel，有的话就返回那个channel实例。一个被选出来的Channel，我们可以把它视为一个data block，我们并不知道这个block里面有多少完整的消息，也许是一条，也是大于或者小于一条，总之，极有可能是不完整的、部分的消息。

* 我们在处理这些不完整的信息的时候，需要做两件事，这两件事都充满了挑战：
  * 我们想要更少的信息拷贝，拷贝的次数越少，则性能越高。
  * 为了使得消息解析的时候更加方便，我们需要把完整的信息存储在连续的字节数组中。

* 检测信息
 * 检测信息需要MessageReader从block中查看是否有至少一条完整的信息，如果有的话，则该完整信息可以拿出来进行处理。以上的步骤，需要重复多次，所以最好能提高处理的效率。
 * 当block中有不完整的信息，我们则需要把不完整的信息存储起来，直到它的另一部分从channel里面到达使其成为完整的信息。
 * 检查完整信息和存储不完整信息，都是MessageReader的责任，为了不使不同的channel的消息混淆，我们需要让每个channel拥有一个属于自己的MessageReader。
 * 当我们从selector取出一个可以被read的channel的时候，其对应的MessageReader就会从channel中读取消息并且进行消息的分解，如果发现有完整的信息，则把该信息交给处理该信息的组件。
 * 每一个MessageReader都是为指定的协议工作的，它需要知道它所读的信息的的格式。

* 存储信息
 * 做设计存储信息的时候，需要考虑两点:A.我们想要更少的信息拷贝，拷贝的次数越少，则性能越高。B.为了使得消息解析的时候更加方便，我们需要把完整的信息存储在连续的字节数组中。
 * 给每个MessageReader持有一个Buffer
   * 那么这个buffer需要的大小是多少呢？它需要大到至少能存储我们能接受得到的最大的消息的大小。如果我们能接收的最大消息体是10M，则改buffer的体积就需要是10M。
   * 但是我们不可能真的给每个buffer都这么大到体积，因为如果我们拥有1000000这样的示例的话，则我们需要相当大的内存，况且并不是每个消息体都这么大，给每个buffer10M的体积，无疑是非常浪费且不实际的做法。
 * 设计可伸缩的buffer:给每个MessageReader持有一个可伸缩的buffer，这个buffer一开始的体积会很小，如果消息体的体积大于buffer的体积的时候，则使buffer扩展。
 * 如何设计可伸缩的buffer---resize by copy
   * 假如一开始我们拥有一个4KB的buffer，如果我们发现我们的消息体放不进去，则我们再分配一个8KB的buffer，然后把4KB的buffer的数据拷贝出来，连同channel余下的信息一起放到8KB的buffer中去。如果数据大于8KB，则分配一个更大的，如此循环。
   * resize-by-copy的做法的优点是：信息将会存在一个单独的、连续性的字节数组中，这会让消息的解析更加方便。
   * resize-by-copy的做法的缺点是：当消息体过大的时候，则需要多次的数组分配和数据拷贝，这将影响性能。
   * 减少数据拷贝和数组分配的次数的关键做法是，需要从你的应用系统中进行分析，看看主要有什么规模的数据，然后制定对应的相关规模的buffer。比如说，你发现你的系统会收到很多低于4KB的信息。则你的第一个buffer的大小可以是4KB。接着，你还发现你有不少数量的大于4KB小于128KB的信息，比如包含了一些小的上传文件，则此时可以设定第二个buffer的大小是128KB。最后，你还发现你有一些大于128KB的信息输入，则第三个buffer按照信息体的最大体积制定。
   * 此时，根据系统分析，你已经制定了三个不同体积大小的buffer，分别是4KB,128KB以及1MB（假设这是消息体的最大体积）。则当消息大于4KB小于128KB的时候，只需要一次数据拷贝和数组分配，如果是大于128KB的时候，则是两次。这样子的次数和数据拷贝量并不算多。最多只需要拷贝4KB+128KB=132KB的数据。
   * 当消息被完全处理好的时候，需要对分配的内存进行释放。然后新的链接还是从4KB的buffer开始走程序。
